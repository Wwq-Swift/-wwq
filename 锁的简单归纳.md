# -wwq
一些 书籍 资料 阅读随笔

Ios 开发中常见的两种锁： 自旋锁和互斥锁
1. 互斥锁: 同一时刻只能有一个线程获得互斥锁,其余线程处于挂起状态.
2. 自旋锁: 当某个线程获得自旋锁后,别的线程会一直做循环,尝试加锁,当超过了限定的次数仍然没有成功获得锁时,线程也会被挂起.（自旋锁较适用于锁的持有者保存时间较短的情况下,实际使用中互斥锁会用的多一些.）

###一。互斥锁，信号量
1.遵守NSLocking协议的四种锁
四种锁分别是:
NSLock、NSConditionLock、NSRecursiveLock（递归锁（可以同时加多个锁）并且不会造成死锁）、NSCondition  

###二。GCD的DispatchSemaphore和栅栏函数 1. dispatchSemaphore （信号量）
DispatchSemaphore中的信号量,可以解决资源抢占的问题,支持信号的通知和等待.每当发送一个信号通知,则信号量+1;每当发送一个等待信号时信号量-1,如果信号量为0则信号会处于等待状态.直到信号量大于0开始执行.所以我们一般将DispatchSemaphore的value设置为1.

（可以设置信号量的初始数值，根据数目来控制当前队列的处于执行的线程数目，其他线程挂起等待（阻塞线程并休眠））  

####2.2. barrier栅栏函数: 栅栏函数也可以做线程同步,当然了这个肯定是要并行队列中才能起作用.只有当当前的并行队列执行完毕,才会执行栅栏队列.

###三。其他的互斥锁
1. pthread_mutex互斥锁  pthread表示POSIX thread,跨平台的线程相关的API,pthread_mutex也是一种互斥锁,互斥锁的实现原理与信号量非常相似,阻塞线程并睡眠,需要进行上下文切换. 一般情况下,一个线程只能申请一次锁,也只能在获得锁的情况下才能释放锁,多次申请锁或释放未获得的锁都会导致崩溃.假设在已经获得锁的情况下再次申请锁,线程会因为等待锁的释放而进入睡眠状态,因此就不可能再释放锁，从而导致死锁.

1. @synchronized条件锁 日常开发中最常用的应该是@synchronized,这个关键字可以用来修饰一个变量,并为其自动加上和解除互斥锁.这样,可以保证变量在作用范围内不会被其他线程改变.但是在swift中它已经不存在了.其实@synchronized在幕后做的事情是调用了objc_sync中的objc_sync_enter和objc_sync_exit 方法，并且加入了一些异常判断.

func synchronized(lock: AnyObject, closure: () -> ()) {
    objc_sync_enter(lock)
    closure()
    objc_sync_exit(lock)
}   

事例（将某个对象锁住，保证当前只有一个线程可以访问这个对象）

####2. 自旋锁
1. OSSpinLock自旋锁
OSSpinLock是执行效率最高的锁,不过在iOS10.0以后已经被废弃了.

2. os_unfair_lock自旋锁
它能够保证不同优先级的线程申请锁的时候不会发生优先级反转问题.这是苹果为了取代OSSPinLock新出的一个能够避免优先级带来的死锁问题的一个锁,OSSPinLock就是有由于优先级造成死锁的问题. </br>

注意: 这个锁适用于小场景下的一个高效锁,否则会大量消耗cpu资源.
